# 【八股】进程管理

## 1 进程、程序与线程概念

### 1.1 进程与程序的区别？

- 程序：通常为二进制程序，放置于存储介质中（如硬盘、光盘等），以 **物理文件** 的形式存在。
- 进程：程序触发后，执行者的权限与属性、程序代码与所需数据会被加载到内存中，操作系统给予这个内存中的单元一个标识符（PID）。可以说，**进程是一个正在运行的程序**。

### 1.2 进程与线程的区别？

线程是进程划分成的更小的 **运行单位**，一个进程在其执行的过程中可以产生多个线程。

<img src="./【八股】进程管理.assets/image-20230220103711724.png" alt="image-20230220103711724" style="zoom: 67%;" />

多个线程共享进程的 **堆** 和 **方法区 (JDK1.8 之后的元空间)** 资源，但是每个线程有自己的 **程序计数器**、**虚拟机栈** 和 **本地方法栈**。

> 总的来说：
>
> - 线程和进程最大的不同在于 **基本上各进程是独立的，而各线程则不一定**，因为同一进程中的线程极有可能会相互影响。
> - 线程执行开销小，但不利于资源的管理和保护；而进程正相反。
> - 进程是 **资源分配** 的最小单位，线程是 **资源调度** 的最小单位。

## 2 进程具有哪些状态？

一般把进程大致分为 5 种状态：

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![image-20230220104234399](./【八股】进程管理.assets/image-20230220104234399.png)

## 3 进程之间有哪些常见的通信方式？

1. **管道/匿名管道(Pipes)** ：用于具有 **亲缘关系** 的父子进程间或者兄弟进程之间的通信。

   特点：**半双工**，只存在于 **内存** 的特殊文件

2. **有名管道(Named Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 **先进先出(first in first out)**。有名管道以 **磁盘文件** 的方式存在，可以实现本机任意两个进程通信。

3. **信号(Signal)** ：Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。**信号是软件层次上对中断机制的一种模拟**，是一种异步通信方式。

   > **Linux系统中常用信号：**
   >
   > - **SIGHUP：**用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
   > - **SIGINT：**程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
   > - **SIGQUIT：**程序退出信号。程序运行过程中，按`Ctrl+\\`键将产生该信号。
   > - **SIGBUS 和 SIGSEGV：**进程访问非法地址。
   > - **SIGFPE：**运算中出现致命错误，如除零操作、数据溢出等。
   > - **SIGKILL：**用户终止进程执行信号。shell下执行`kill -9`发送该信号。

4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在 **内核** 中并由消息队列标识符标识。

   管道和消息队列的通信数据都是 **先进先出** 的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是 **消息队列存放在内核中，只有在内核重启（即，操作系统重启）或者显式地删除一个消息队列时，该消息队列才会被真正的删除。**

   消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。**

5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于 **进程间同步**。这种通信方式主要用于 **解决与同步相关的问题并避免竞争条件**。

6. **共享内存(Shared memory)** ：使得 **多个进程可以访问同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种 **同步操作**，如互斥锁和信号量等，来达到进程之间的同步和互斥。可以说这是最有用的进程间通信方式。

   > 如：`mmap()` 系统调用通过共享内存实现零拷贝。`mmap()` 系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用 `read()`，`write()`等操作。

7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的 **基本操作单元**，可以看做是不同主机之间的进程进行 **双向通信** 的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

## 4 线程之间的同步方式有哪些？

线程同步是 **两个或多个 共享关键资源 的线程的并发执行**，应该同步线程 **以避免关键的资源使用冲突**。操作系统一般有下面三种线程同步的方式：

1. **互斥量 (Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 `synchronized` 关键词和各种 `Lock` 都是这种机制。
2. **信号量 (Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的 **最大线程数量**。
3. **事件 (Event)** `Wait/Notify`：通过 **通知操作** 的方式来保持多线程同步，还可以方便的实现 **多线程优先级** 的比较操作。

## 5 进程的调度算法有哪些?

进程调度算法也称 **CPU 调度算法**。当 CPU 空闲时，操作系统就从就绪队列中按照一定的算法选择某个 **就绪状态** 的进程，并给其分配 CPU。

- **先到先服务 (FCFS) 调度算法** : 从就绪队列中选择一个 **最先进入** 该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先 (SJF) 的调度算法** : 从就绪队列中选出一个 **估计运行时间最短** 的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin) 调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **优先级调度** ：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。
- **多级反馈队列算法** ：「多级」表示有 **多个队列**，每个队列优先级从高到低，同时 **优先级越高时间片越短**。「反馈」表示 **如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列**。对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。UNIX 操作系统采取的便是这种调度算法。

## 6 什么是死锁？

死锁描述的是这样一种情况：多个进程/线程 **同时被阻塞**，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

多个进程或线程在运行过程中因 **争夺资源** 而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

## 7 产生死锁的四个必要条件是什么?

四大必要条件：

1. **互斥** ：资源必须处于 **非共享** 模式，即在一段时间内某资源仅为一进程所占用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
2. **占有并等待**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **非抢占**：资源 **不能被抢占**。已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. **循环等待**：有一组等待进程 `{P0, P1,..., Pn}`， `P0` 等待的资源被 `P1` 占有，`P1` 等待的资源被 `P2` 占有，......，`Pn-1` 等待的资源被 `Pn` 占有，`Pn` 等待的资源被 `P0` 占有。

这四个条件是产生死锁的 **必要条件** ，也就是说只要系统发生死锁，这些条件必然成立，而 **只要上述条件之一不满足，就不会发生死锁。**

## 8 如何解决死锁？

解决死锁的方法可以从多个角度去分析，一般的情况下，有 **预防，避免，检测和解除四种**。

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免** 则是系统在分配资源时，根据资源的使用情况 **提前做出预测**，从而 **避免死锁的发生**
- **检测** 是指系统设有 **专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。

### 预防死锁

破坏第一个条件 **互斥条件**：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 **往往是不能同时访问的** ，所以这种做法在大多数的场合是行不通的。

破坏第三个条件 **非抢占** ：也就是说可以采用 **剥夺式调度算法**，但剥夺式调度方法目前一般仅适用于 **主存资源** 和 **处理器资源** 的分配，并不适用于所有的资源，会导致 **资源利用率下降**。

所以一般比较实用的 **预防死锁的方法**，是通过考虑破坏第二个条件和第四个条件。

#### 1、静态分配策略

静态分配策略可以 **破坏死锁产生的第二个条件（占有并等待）**。所谓静态分配策略，就是指 **一个进程必须在执行前就申请到它所需要的全部资源，并且直到它所要的资源都得到满足之后才开始执行**。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。

静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 **几乎不用的资源而使其他需要该资源的进程产生等待** 的情况。

#### 2、层次分配策略

层次分配策略 **破坏了产生死锁的第四个条件（循环等待）**。在层次分配策略下，**所有的资源被分成了多个层次**，一个进程得到某一次的一个资源后，它 **只能再申请较高一层的资源**；当一个进程要释放某层的一个资源时，**必须先释放所占用的较高层的资源**，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。

### 死锁避免

上面提到的 **破坏** 死锁产生的四个必要条件之一就可以成功 **预防系统发生死锁** ，但是会导致 **低效的进程运行** 和 **资源使用率** 。而死锁的避免相反，它的角度是允许系统中 **同时存在四个必要条件** ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 **明智和合理的选择** ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。

我们将系统的状态分为 **安全状态** 和 **不安全状态** ，每当在未申请者分配资源前先测试系统状态，**若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源**。

> 如果操作系统能够 **保证所有进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的**。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。

那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 **避免死锁算法** 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，**银行家算法** 通过先 **试探** 分配给该进程资源，然后通过 **安全性算法** 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 **真的分配资源给该进程**。

死锁的避免(银行家算法)改善了 **资源使用率低的问题** ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 **安全性检查** ，需要花费较多的时间。

### 死锁的检测

对资源的分配加以限制可以 **预防和避免** 死锁的发生，但是都不利于各进程对系统资源的 **充分共享**。解决死锁问题的另一条途径是 **死锁检测和解除** (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 **乐观锁** ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 **死锁的预防和避免** 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。

这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 **定时地运行一个 “死锁检测”** 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。

### 死锁的解除

当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：

1. **立即结束所有进程的执行，重新启动操作系统** ：这种方法简单，但以前所在的工作全部作废，损失很大。
2. **撤销涉及死锁的所有进程，解除死锁后继续运行** ：这种方法能彻底打破 **死锁的循环等待** 条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。
3. **逐个撤销涉及死锁的进程，回收其资源直至死锁解除。**
4. **抢占资源** ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。







