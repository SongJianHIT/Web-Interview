# 【算法】背包问题

<img src="./【算法】背包问题.assets/image-20230227091437495.png" alt="image-20230227091437495" style="zoom:150%;" />

背包问题： **泛指一类「给定 价值 与 成本」，同时「限定决策规则」，在这样的条件下，如何实现价值最大化的问题。** 

## 1、0-1背包问题

> **「01背包」是指给定物品价值与体积（对应了「给定价值与成本」），在规定容量下（对应了「限定决策规则」）如何使得所选物品的总价值最大。**

有 `n` 件物品和一个最多能背重量为 `w` 的背包。第 `i` 件物品的重量是 `weight[i]`，得到的价值是 `value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是 $O(2^n)$ ，这里的 n 表示物品数量。

**所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**

### 二维动规

#### 1）DP数组的含义

一般地，我们定义：`dp[i][j]` 表示前 `i` 件物品（即 `[0,i]` ）任取放入一个容量为 `j` 的背包可以获得的最大价值。

#### 2）递推公式

当前的状态，是针对 **当前的物品，放 或者 不放**。 

状态转移过程可表示为：

- 不选择第 `i` 件物品：问题转化为了前 `i−1` 件物品放入容量为 `j` 的背包中所获得的价值：`dp[i][j]=dp[i−1][j]`
- 选择第 `i` 件物品：第 `i` 件物品占据容量 `wi`，前 `i−1` 件物品放入剩下的容量为 `j−wi` 的背包中，问题也就转化为了前 `i−1` 件物品放入容量为 `j−wi` 的背包中所获得的价值 `dp[i−1][j−wi]` 加上要放入的第 `i` 件物品的价值 `vi`：`dp[i][j]=dp[i−1][j−wi]+vi`，注意，能放入第 `i` 件物品的前提为：`wi ≤ j`。

两种情况取较大者：
$$
d p[i][j]=\max \left\{d p[i-1][j], \quad d p[i-1]\left[j-w_i\right]+v_i\right\}
$$

#### 3）DP数组初始化

哪些元素应该初始化和如何初始化都是需要根据题意进行判断的。

首先从 `dp[i][j]` 的定义出发，如果背包容量 j 为 0 的话，即 `dp[i][0]`，无论是选取哪些物品，背包价值总和一定为 0。

![image-20230227092834873](./【算法】背包问题.assets/image-20230227092834873.png)

状态转移方程 `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);` 可以看出 i 是由 i-1 推导出来，那么 i 为 0 的时候就一定要初始化。

`dp[0][j]` ，即：i 为 0，存放编号 0 的物品的时候，各个容量的背包所能存放的最大价值。

#### 4）确定遍历顺序

那么问题来了，**先遍历 物品还是先遍历背包重量呢？其实都可以！！ 但是先遍历物品更好理解**。

```java
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

### 一维动规：滚动数组

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

**其实可以发现如果把 dp[i - 1] 那一层拷贝到 dp[i] 上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);`**

**与其把 dp[i - 1] 这一层拷贝到 dp[i] 上，不如只用一个一维数组了**，只用 dp[j]（一维数组，也可以理解是一个滚动数组）。

#### 1）DP数组的含义

`dp[j]`：容量为 `j` 的背包所背的最大价值。

#### 2）递推公式

此时 dp[j] 有两个选择：

- 一个是取自己 `dp[j]`：相当于 二维dp数组中的 `dp[i-1][j]`，即不放物品i
- 一个是取 `dp[j - weight[i]] + value[i]`：放物品`i`

```java
dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
```

#### 3）DP数组初始化

`dp[j]` 表示：容量为 j 的背包，所背的物品价值可以最大为 `dp[j]` 。

那么 `dp[0]` 就应该是 0，因为背包容量为 0 所背的物品的最大价值就是 0。

#### 4）确定遍历顺序

代码如下：

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 倒叙遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！**

**二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。**

为什么呢？

- **倒序遍历是为了保证物品 i 只被放入一次！**但如果一旦正序遍历了，那么物品 0 就会被重复加入多次！

**再来看看两个嵌套 for 循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

- 不可以！
- 因为一维 dp 的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此 **需要保证左边的值仍然是上一层的，从右向左覆盖。**

### 0-1背包变体

1. 至多能装 capacity，求方案数 / 最大价值和
2. 恰好能装 capacity，求方案数 / 最大 / 最小价值和
3. 至少能装 capacity，求方案数 / 最小价值和

> 补充：
>
> - 求有多少种组合（方案）问题：设 `dp[j]` 为装满 j 大小的背包有 dp[j] 种组合，递推公式写成 `dp[j] += dp[j - weight[i]]` 

## 2、完全背包问题

有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 `weight[i]` ，得到的价值是 `value[i]` 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件**。

首先在回顾一下01背包的核心代码：

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量，倒序遍历
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```java
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量，正序遍历
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**对于纯完全背包问题，其 for 循环的先后循环是可以颠倒的！** 但如果题目稍稍有点变化，就会体现在遍历顺序上。

如果问装满背包有几种方式的话？ 那么两个 for 循环的先后顺序就有很大区别了，而 leetcode 上的题目都是这种稍有变化的类型。

> **如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包**。
>
> **如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品**。

## 3、多重背包问题

有 `N` 种物品和一个容量为 `V` 的背包。第 `i` 种物品最多有 `Mi` 件可用，每件耗费的空间是 `Ci` ，价值是 `Wi` 。

求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

> 解决方法：**将多重背包问题转化为 0-1 背包问题！**

如：背包最大重量为10。物品为：

![image-20230308090309440](./【算法】背包问题.assets/image-20230308090309440.png)

其实等价于：

![image-20230308090319027](./【算法】背包问题.assets/image-20230308090319027.png)

然后采用 0-1 背包解就行。

## 题目汇总

| 题目                                                         | 类型 |           特点           |
| :----------------------------------------------------------- | :--: | :----------------------: |
| [416.分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/?orderBy=hot) | 0-1  |        求最大价值        |
| [1049.最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) | 0-1  |        求最大价值        |
| [494.目标和](https://leetcode.cn/problems/target-sum/)       | 0-1  |          求组合          |
| [474.一和零](https://leetcode.cn/problems/ones-and-zeroes/)  | 0-1  | 二维背包问题，求最大价值 |
| [377.组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/) | 完全 |          求排列          |
| [518.零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/description/) | 完全 |          求组合          |
| [322.零钱兑换](https://leetcode.cn/problems/coin-change/)    | 完全 |        最少物品数        |
| [279.完全平方数](https://leetcode.cn/problems/perfect-squares/description/) | 完全 |        最少物品数        |
| [139.单词拆分](https://leetcode.cn/problems/word-break/description/) | 完全 |          求组合          |

## 技巧总结

### 递推公式总结

1. **能否装满背包** 或 **最多装多少** 或 **最大物品总价值** ？

```java
dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
```

2. **装满背包有几种方法** 或 **求方案数** ？

```java
dp[j] += dp[j - values[i]];
```

3. **装满背包所有物品的最小个数** ？

```java
dp[j] = min(dp[j - costs[i]] + 1, dp[j]);
```

### 遍历顺序总结

1. 0-1背包问题
   - 二维 0-1 背包，可以 **先遍历物品** 也可以 **先遍历背包**，且第二层 for 循环是从小到大遍历。
   - 一维 0-1 背包，只能先遍历物品再遍历背包容量，并且第二层 for 循环是 **从大到小** 遍历。
   - 反正一般就用一维的，记住 **先物品后背包，背包遍历需逆序！**
2. 完全背包问题
   - 先遍历物品还是先遍历背包都是可以的，且第二层 for 循环是 **从小到大** 遍历（背包正序遍历）。
   - 求组合：先物品，后背包
   - 求排列：先背包，后物品
3. 多重背包问题，转化为 0-1 背包进行求解！









































