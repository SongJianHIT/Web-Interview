# 【算法】树

## 1 遍历问题

### 1.1 前、中、后序遍历

递归版本：

```java
// 前序遍历·递归·LC144_二叉树的前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        preorder(root, result);
        return result;
    }

    public void preorder(TreeNode root, List<Integer> result) {
        if (root == null) {
            return;
        }
        result.add(root.val);
        preorder(root.left, result);
        preorder(root.right, result);
    }
}

// 中序遍历·递归·LC94_二叉树的中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }

    void inorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        inorder(root.left, list);
        list.add(root.val);
        inorder(root.right, list);
    }
}

// 后序遍历·递归·LC145_二叉树的后序遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }

    void postorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        postorder(root.left, list);
        postorder(root.right, list);
        list.add(root.val);
    }
}
```

非递归版本：

```java
// 先序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        pre(root, res);
        return res;
    }

    private void pre(TreeNode root, List<Integer> res) {
        if (root == null) return;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            res.add(node.val);
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
        }
    }
}

// 中序遍历
class Solution {
  
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        in(root, res);
        return res;
    }

    private void in(TreeNode root, List<Integer> res) {
        if (root == null) return;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                // 走到最左下的位置
                stack.push(cur);
                cur = cur.left;
            } else {
                // 访问节点
                cur = stack.pop();
                // 中
                res.add(cur.val);
                // 右
                cur = cur.right;
            }
        }
    }
}

// 后序遍历
class Solution {

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        post(root, result);
        // 反转：中右左 -> 左右中
        Collections.reverse(result);
        return result;
    }

    // 修改先序代码，中左右 -> 中右左
    private void post(TreeNode root, List<Integer> res) {
        if (root == null) return;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            res.add(node.val);
            if (node.left != null) stack.push(node.left);
            if (node.right != null) stack.push(node.right);
        }
    }
}
```

### 1.2 层序遍历

迭代实现：

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        var res = new ArrayList<List<Integer>>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
          	// tmp 存储每一层节点
            var tmp = new ArrayList<Integer>();
            // 获取该层节点个数
            int size = queue.size();
            // 遍历该层
            while (size > 0) {
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
                size--;
            }
            res.add(tmp);
        }
        return res;
    }
}
```

#### 相关题目

| 题目                                                         | 类型              | 注释                                               |
| ------------------------------------------------------------ | ----------------- | -------------------------------------------------- |
| [102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/) | 层序遍历          | 常规的层序遍历                                     |
| [107.二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/) | 层序遍历          | 在102的基础上 reverse 就行                         |
| [199.二叉树的右视图](https://leetcode.cn/submissions/detail/418166600/) | 层序遍历          | 记录每层最后一个节点即可                           |
| [637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/) | 层序遍历          | 记录每层的平均值即可                               |
| [429.N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/) | 层序遍历          | N 叉树与二叉树没啥区别，遍历孩子即可               |
| [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | 层序遍历          | 计算层数更新最大层数即可                           |
| [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/) | 层序遍历          | 当第一个出现在层序遍历中，左右孩子为空的节点，返回 |
| [226.翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/description/) | 层序遍历、DSF遍历 | 可以使用中序DFS，也可以使用层序，每次交换左右      |
| [257.二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/description/) | 先序遍历          | 使用先序遍历，注意path数组的元素加入和删除         |

## 2 对称问题

判断二叉树是否对称，可以用 **递归** 和 **非递归** 实现。

```java
// 递归实现
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    private boolean compare(TreeNode leftNode, TreeNode rightNode) {
        if (leftNode == null && rightNode == null) {
            return true;
        } else if (leftNode != null && rightNode == null) {
            return false;
        } else if (rightNode != null && leftNode == null) {
            return false;
        } else if (rightNode.val != leftNode.val) {
            return false;
        } 
        else {
            return compare(leftNode.left, rightNode.right) && compare(leftNode.right, rightNode.left);
        }
    }
}
```

非递归实现：

![101.对称二叉树](./【算法】树.assets/101.对称二叉树.gif)

```java
// 使用队列模拟动图过程
class Solution {
    public boolean isSymmetric(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
      	// 根节点的左右子树入队
        queue.offer(root.left);
        queue.offer(root.right);

        while (!queue.isEmpty()) {
          	// 每次取队头前两个节点
            TreeNode leftNode = queue.poll();
            TreeNode rightNode = queue.poll();

            if (leftNode == null && rightNode == null) {
                continue;
            }

            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
						// 注意这个顺序，先比较外侧，再比较内侧
            queue.offer(leftNode.left);
            queue.offer(rightNode.right);
            queue.offer(leftNode.right);
            queue.offer(rightNode.left);
        }

        return true;
    }
}
```

#### 相关题目

| 题目                                                         | 类型         | 注释 |
| ------------------------------------------------------------ | ------------ | ---- |
| [101.对称二叉树](https://leetcode.cn/problems/symmetric-tree/description/) | 递归、非递归 | easy |
| [100.相同的树](https://leetcode.cn/problems/same-tree/)      | 递归、非递归 | easy |
| [572.另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/) | 递归、非递归 | easy |

## 3 节点个数问题

例题：[222.完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

当然，本题可以通过遍历整棵树来得到所有的节点个数，这样的时间复杂度是 $O(n)$。

但这个模块想强调的是，**满二叉树节点数量计算公式**，
$$
满二叉树中节点个数 = 2^{树高}-1
$$
但，满二叉树与完全二叉树是不同的，如何利用上述公式求解呢？

我们可以通过递归，从子树的视角出发，**只要满足 `左子树高度 = 右子树高度` 的根节点，这个根节点下的树就是一颗满二叉树，无需遍历所有节点！**

<img src="./【算法】树.assets/20201124092543662.png" alt="222.完全二叉树的节点个数" style="zoom:50%;" />

完全二叉树（二）如图： 

<img src="./【算法】树.assets/20201124092634138.png" alt="222.完全二叉树的节点个数1" style="zoom:50%;" />

所以这种思路的代码：

```java
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        TreeNode leftNode = root.left;
        TreeNode rightNode = root.right;
        int leftDepth = 0, rightDepth = 0;
        while (leftNode != null) {
            leftNode = leftNode.left;
            leftDepth++;
        }
        while (rightNode != null) {
            rightNode = rightNode.right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            // 满二叉树计算公式
            return (2 << leftDepth) - 1;
        }
        // 如果当前不是满二叉树，那么就通过最原始的方法计算
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

该算法的时间复杂度： $T(n) = T(n/2) + logn$，通过主定理可求解 $O(logn * logn)$

## 4 树形dp

以 [110.平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/) 为例，树形 dp 是一个比较固定的模版。

```java
class Solution {
		// 定义 dp 过程中，需要保存的信息
    class Info {
        boolean isbal;
        int height;

        public Info(boolean isbal, int height) {
            this.isbal = isbal;
            this.height = height;
        }
    }
		
  	// 这个信息 Info 会伴随着遍历更新
    private Info process(TreeNode root) {
        if (root == null) {
            return new Info(true, 0);
        }
      	// 对当前节点 root，递归得到 左孩子信息 和 右孩子信息
        Info leftInfo = process(root.left);
        Info rightInfo = process(root.right);
      	// 处理信息
        if (rightInfo.isbal && leftInfo.isbal 
            && Math.abs(rightInfo.height - leftInfo.height) <= 1) {
                return new Info(true, Math.max(rightInfo.height, leftInfo.height) + 1);
            }
        return new Info(false, Math.max(rightInfo.height, leftInfo.height) + 1);
    }

    public boolean isBalanced(TreeNode root) {
        return process(root).isbal;
    }
}
```

题单：

| 题目                                                         | 类型   | 注释 |
| ------------------------------------------------------------ | ------ | ---- |
| [110.平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/) | 树形dp | easy |
|                                                              |        |      |
|                                                              |        |      |
|                                                              |        |      |
|                                                              |        |      |













































































