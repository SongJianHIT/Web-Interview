# 【八股】Mysql

## 1 Mysql原理

### 1、什么是索引？Mysql采用什么数据结构建索引？

- 索引的本质是为了让数据库能够快速查找数据，而单独维护的数据结构
- 索引相当于我们给数据库的数据加了目录一样，可以快速的找到数据，简单来说是提高数据查询的效率
- Mysql 中常用的引擎（InnoDB 和 MyISAM）采用 B+ Tree 作为索引
- 不用二叉树的原因是：每层只有两个节点，导致树非常深，导致磁盘IO次数过大
- 不用 B Tree 的原因是：
  - 键值和数据都存在树节点中，会造成极大的内存浪费和性能消耗
  - 不能进行范围查询（没有循环链表连起来）
- B+ Tree 的优点：
  - 能够进行范围查询
  - 叶子结点存储数据，非叶子结点只存储键值
  - 多路平衡树，磁盘IO不大，性能稳定

### 2、为什么Mysql中规定每张表中都需要设置主键？

InnoDB 是 MySQL 数据库的默认引擎，它按照每张表的 **主键** 构造一棵 B+ 树，主键对应的索引是 **聚簇索引** ，在每个叶子节点存放着数据表的行数据。所以主键对于 InnoDB 来说至关重要。

- 用户定义了主键，那么 InnoDB 会使用主键作为聚簇索引；
- 用户没有定义主键，那么 InnoDB 会使用 **第一个非空的唯一索引** 作为聚簇索引；
- 用户既没有定义主键，也没有定义唯一索引，那么 InnoDB 会 **自动生成一个不可见的 ROW_ID** 的列名为 `GEN_CLUST_INDEX` 的聚簇索引，该列是一个 6 字节的自增数值，随着插入而自增。

所以，即便不设置主键，InnoDB 也会花费空间去构建聚簇索引，并且该索引不可见，无法被业务使用。所以最好每张表都设置索引。

### 3、雪花id是什么？如何计算的？

雪花 ID（Snowflake ID）是一种 **分布式系统中用于生成唯一标识符** 的算法。雪花ID是一个 **64** 位的整数，由以下三部分组成：

1. **时间戳**（41位）：精确到毫秒级别的时间戳，可以使用69年。

2. **机器ID**（10位）：用于标识生成ID的机器，可以部署在 **1024** 台机器上。

3. **序列号**（12位）：每台机器每毫秒可以生成4096个ID。

通过这三部分的组合，**可以保证在分布式系统中生成唯一的ID** 。雪花ID在分布式系统中广泛应用，例如在分布式数据库、分布式缓存等场景中，用于唯一标识不同的数据或对象。

### 4、能否使用雪花id作为数据库主键？

可以，但需要注意以下几点：

1. 雪花 ID 生成的是一个 64 位整数，需要将其转换成 MySQL 数据库中对应的数据类型，通常是 BIGINT 或者 UNSIGNED BIGINT。
2. 雪花 ID 生成的 **顺序并不是按照数字大小的顺序递增，而是按照时间戳和机器ID生成的顺序递增** ，因此不能保证雪花 ID 在MySQL 数据库中的顺序是按照插入顺序递增的。
3. 如果需要在 MySQL 数据库中使用雪花 ID 作为主键，需要在数据库中创建一个自增列作为主键，同时将雪花ID作为另外一个列保存到数据库中，以便后续查询和使用。
4. 雪花 ID 的生成需要 **保证机器 ID 的唯一性**，如果机器 ID 有重复的情况，会导致生成的雪花 ID 重复，因此需要特别注意机器 ID 的设置。

综上所述，可以使用雪花 ID 作为 MySQL 数据库的主键，但需要特别注意上述问题，确保数据的正确性和完整性。

### 5、雪花id是严格单调递增的吗？

> 大致递增：相同机器、相同毫秒内，根据时间戳和机器id 大致递增。

雪花ID并不是严格递增的，而是 **大致递增**。雪花ID的生成规则是由 **时间戳、机器ID 和 序列号** 组成的，其中时间戳和机器 ID 可以保证全局唯一性，序列号用于解决同一毫秒内多次生成ID的冲突问题。

但是，**序列号并不是按照递增的顺序生成的，而是采用了一种循环递增的方式，每毫秒最多可以生成 4096 个ID** ，当超过这个数量时，序列号会从0开始重新计数。

因此，雪花ID **在同一毫秒内生成的ID是按照时间戳和机器ID递增的**，但是在不同毫秒内生成的ID之间并没有严格的递增关系。同时，由于序列号是循环递增的，因此也不能保证在不同毫秒内生成的ID之间是严格递增的。

如果需要按照严格递增的顺序生成ID，可以考虑使用其他算法，如数据库的自增ID。

### 6 可以使用uuid作为数据库主键吗？

**可以**。UUID 是一种 128 位的唯一标识符，可以保证全局唯一性，因此可以作为数据库主键使用。

优点：它不需要在数据库中进行自增操作，因此可以避免自增主键带来的单点故障问题和高并发下的性能瓶颈。此外，**使用 UUID 作为主键可以使得分布式系统中的不同节点之间无需进行主键冲突的协调，提高了系统的可扩展性。**

缺点：

- UUID是一个较长的 **字符串**，比整型主键占用更多的 **存储空间**，因此可能会对数据库的存储和索引性能产生一定的影响
- UUID本身是无序的，如果使用它作为主键，可能会导致 **数据的物理存储顺序与主键顺序不一致，因此可能会对基于主键排序的查询操作的性能产生影响**

在决定是否使用 UUID 作为数据库主键时，需要考虑具体的业务需求和数据规模。

### 7 什么是联合索引的最左原则？

在 MySQL 建立联合索引时会遵循 **最左前缀匹配** 的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。

例如，假设有一个联合索引 (a, b, c) ，如果要查询满足 a=1、b=2 和c=3 的记录，那么使用这个索引可以高效地定位到符合条件的记录。但是，如果要查询满足b=2和c=3的记录，那么只有包含索引的前两个列（b和c）的部分查询条件是不能利用索引的，需要进行全表扫描来查找符合条件的记录，因为查询条件不满足最左前缀原则。

### 8 说说聚簇索引和非聚簇索引？

聚簇索引和非聚簇索引都是数据库中常用的 **索引类型**，它们的实现方式和性质有所不同。

【聚簇索引】是 **将数据存储在索引中**，即 **将索引树的叶子节点存储为数据行**，因此聚簇索引的叶子节点存储的 **数据行按照索引键的顺序进行物理存储** ，而且每张表只能有一个聚簇索引。聚簇索引的优点是能够提高查询性能，因为它可以通过索引顺序快速定位到数据行，减少磁盘I/O操作。缺点是在 `插入、更新和删除` 等操作时需要 **对数据行进行重排序**，因此会对性能产生一定的影响。

【非聚簇索引】是 **将数据和索引分开存储**，即 **索引树的叶子节点只包含索引值和指向数据行的指针，而不是数据行本身** 。非聚簇索引可以在一张表中创建多个，它的优点是能够提高数据修改的性能，因为数据修改时不需要对数据行进行重排序，只需要对相应的索引进行更新即可。缺点是在查询时需要进行 **两次I/O操作**，**先查找索引，再根据索引值查找数据行**，因此查询性能相对于聚簇索引较差。

一般来说，聚簇索引适用于经常需要 `范围查询、排序和分组` 等操作的列，而非聚簇索引适用于 `经常需要更新的列` 。在具体的数据库设计中，需要根据数据的特性和查询需求来选择合适的索引类型。

### 9 Mysql中锁的分类？

根据操作分：

- 读锁（共享锁）
- 写锁（排他锁）

根据粒度划分：

- 表锁
- 页锁
- 行锁

根据思想划分：

- 乐观锁
- 悲观锁

### 10、什么是乐观锁和悲观锁？

乐观锁和悲观锁是常用的 **并发控制** 方式。

> 【悲观锁】 **假设会发生并发冲突，因此在访问共享资源之前会先加锁，其他线程想要访问这个资源时必须等待锁的释放。** 

悲观锁 **适用于并发冲突比较严重** 的场景，例如高并发访问数据库或共享文件系统等。在数据库中，悲观锁可以通过在事务中使用`SELECT … FOR UPDATE` 或 `UPDATE … WHERE` 语句来实现，获取锁后可以进行修改或读取操作，释放锁时会提交事务。

> 【乐观锁】 **假设并发冲突不会发生，因此在访问共享资源之前不加锁，而是在数据更新时判断是否有其他线程修改过这个数据，如果没有则进行更新，否则放弃当前操作。**

乐观锁 **适用于并发冲突不频繁** 的场景，例如缓存系统、购物车等。在数据库中，乐观锁可以通过在数据表中添加一个 **版本号字段**，每次更新数据时将版本号+1，更新时检查版本号是否一致来实现。如果版本号不一致，则说明数据已经被其他线程修改过，需要重新读取数据并重试更新操作。

悲观锁的优点在于实现简单、使用方便，但在高并发场景下会导致系统性能下降。乐观锁的优点在于性能好、避免了不必要的锁等待，但实现比较复杂，需要考虑数据的一致性和异常处理等问题。在具体应用中需要根据实际情况选择合适的并发控制方式。

### 11、什么是读锁？

读锁是一种 **共享锁**，也叫共享读锁或共享共存锁。在并发环境中，为了保证数据的一致性和完整性，读操作和写操作之间需要加锁。**读锁的作用是允许多个线程同时读取数据，但不允许对数据进行写操作，即读锁可以共享，而写锁是独占的。**

**当一个线程获得读锁时，其他线程也可以获得读锁，但不能获得写锁。只有当所有读锁都被释放后，才能获得写锁。**

这种 **读写分离** 的机制可以提高并发性能，使得读操作和写操作可以同时进行，而不会互相阻塞。

### 12、什么是写锁？

写锁是一种 **独占锁**，也叫 **排它锁**。在并发环境中，为了保证数据的一致性和完整性，读操作和写操作之间需要加锁。**写锁的作用是禁止其他线程读取或写入数据，只允许当前线程进行写操作。**

**当一个线程获得写锁时，其他线程不能同时获得读锁或写锁，只有当写锁被释放后，其他线程才能获得读锁或写锁。**这种机制可以保证写操作的原子性和排他性，避免并发环境下的数据竞争和冲突。

需要注意的是，**写锁是独占的，因此在多线程环境中，如果某个线程长时间占用写锁，其他线程可能会被阻塞，导致性能问题。** 因此，在使用写锁时需要谨慎，避免对系统性能造成影响。同时，在需要同时保证读写操作的情况下，也需要使用更复杂的锁机制，如读写锁、乐观锁等。

## 2 Mysql调优

### 1、如何找到查询慢的 SQL，以及如何优化？

- 开启慢查询日志(DBA)
- 查找慢查询 SQL
- explain 进行慢查询 SQL 分析
- SQL 语句调优，数据库服务器参数调优(DBA)

### 2、什么字段适合构建索引？

- 表的主键列（primary key）
- 频繁作为查询条件的列
- 查询中，需要进行排序的列
- 查询中，需要进行统计、分组的列
- 不经常变化的列（身份证号、手机号等）

### 3、MySQL如何综合性优化?

可以从以下几个方面考虑：

#### 选择合适的存储引擎

MyISAM: 以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。
InnoDB: 事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。

#### 合理设计表结构

1. 第一范式（1NF）：所有属性都是原子性的，即属性不可再分。每个属性都应该只包含单个的基本数据类型，如整型、浮点型、字符串型等，而不能包含复合类型、数组、集合等。
2. 第二范式（2NF）：表中的每个非主键列都完全依赖于主键，而不是部分依赖。即每个非主键列都要和主键的所有列一起组成一个唯一的组合，而不能只依赖主键的一部分列。
3. 第三范式（3NF）：表中的每个非主键列都不传递依赖于主键。即每个非主键列都必须直接依赖于主键，而不能依赖于其他非主键列。如果一个非主键列依赖于其他非主键列，则应将其拆分为一个新的表。

#### 索引优化

- 表一定要建立主键索引。
- 数据量大的表应该有索引。
- 经常与其他表进行连接的表，在连接字段上应该建立索引。
- 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引。
- 索引应该建在选择性高的字段上（sex 性别这种就不适合）。
- 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引。
- 频繁进行数据操作的表，不要建立太多的索引。
- 删除无用的索引，避免对执行计划造成负面影响。

#### sql语句优化

- SELECT语句务必指明列的名称（避免直接使用select * ）
- SQL语句要避免造成索引失效的写法
- SQL语句中IN包含的值不应过多
- 如果排序字段没有用到索引，就尽量少排序
- 尽量少用or
- 尽量用union all代替 union
- 避免在where子句中对字段进行null值判断
- 不建议使用%前缀模糊查询
- 避免在where子句中对列进行表达式或函数操作

#### 读写分离

> 解决读操作过多的情况

如果数据库的使用场景 **读操作比较多** 的时候，为了避免写操作所造成的性能影响 可以采用读写分离的架构。

读写分离的基本原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理 SELECT 查询操作。

#### MySQL的分库分表

> 解决数据量过大的情况

详见[分库分表](https://github.com/SongJianHIT/Web-Interview/blob/main/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/%E3%80%90Java%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E3%80%91%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.md)。





































